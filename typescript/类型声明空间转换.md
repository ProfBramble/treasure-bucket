## ç±»å‹å£°æ˜ç©ºé—´è½¬æ¢

>  æœ¬ç« èŠ‚ä¸»è¦ä»‹ç» `TypeScript` ä¸­ç±»å‹å£°æ˜ç©ºé—´çš„ä¸€äº›å¥‡æ·«æŠ€å·§ï¼ŒåŒæ—¶ä¹Ÿæ˜¯å¯¹è‡ªèº«å­¦ä¹ åšä¸€ä¸ªé˜¶æ®µæ€§çš„è®°å½•ã€‚äººä»¬ä¸ºäº†åœ¨æ—¥å¸¸å·¥ä½œä¸­ææ•ˆï¼Œå‘æ˜äº†å„ç§æ¦‚å¿µï¼Œåœ¨å‰ç«¯å¼€å‘çš„è§†å›¾ä¸­å‘æ˜äº† `ç»„ä»¶` æ¦‚å¿µï¼ŒReactä¸­ä¸ºäº†æå–å…¬å…±çš„ä¸šåŠ¡é€»è¾‘ï¼Œæ¨å‡ºäº†React Hookï¼ŒåŒæ—¶ä¹Ÿä¸ºæ¨è¿›FPå‘å±•ä½œå‡ºäº†è´¡çŒ®ï¼Œè€Œ TypeScript çš„æ™®åŠï¼Œæ˜¯ä¸æ˜¯ä¹Ÿå¯ä»¥æœ‰æå–å…¬å…±typeçš„è®¾å®šå‘¢ï¼Ÿæœ¬æ–‡å°±é’ˆå¯¹å…¬å…± type çš„åº”ç”¨è¿›è¡Œæ¢è®¨ã€‚

å¦‚æœä½ è§‰å¾—æœ¬æ–‡ç†è§£è¿‡äºåƒåŠ›ï¼Œç¬”è€…å»ºè®®è¿˜æ˜¯å…ˆå¯¹TypeScriptåšä¸€ä¸ªç³»ç»Ÿçš„å­¦ä¹ ï¼Œå†å›è¿‡å¤´æ¥è¿›è¡Œé˜…è¯»ï¼ŒçŸ¥è¯†ç‚¹æˆä½“ç³»åè¿›è¡Œé¡½å›ºï¼Œç»ˆç©¶ä¼šæ¯”ç¢ç‰‡åŒ–çš„ç²¾åå†…å®¹å¸®åŠ©æ›´å¤§ã€‚

#### å…ƒç¥–è½¬è”åˆç±»å‹

##### æ–¹æ³•1

```typescript
type ElementOf<T> = T extends Array<infer E> ? E : never;

type TTuple = [string, number];

type ToUnion = ElementOf<TTuple>; // string | number
```

##### æ–¹æ³•2

```typescript
type TTuples = [string, number];

type Res = TTuples[number]; // string | number
```

æºè‡ª [stackoverflow](https://stackoverflow.com/questions/44480644/string-union-to-string-array/45486495#45486495) ï¼Œè¿™ä¸ªæ¯”è¾ƒğŸ‚ï¼Œ`number`å¯ä»¥ç†è§£ä¸ºè¯»å–æ•°ç»„çš„å…ƒç´ ï¼Œå› æ­¤å¯ä»¥æŠŠæ•°ç»„çš„æ¯ä¸€ä¸ªå…ƒç´ å‡å˜æˆè”åˆç±»å‹ã€‚



#### è·å–å‡½æ•°ç±»å‹

##### è·å–å‡½æ•°çš„è¿”å›å€¼

```typescript
type ReturnType<T> = T extends (...args: any[]) => infer P ? P : any;

type Func = () => User;
type Test = ReturnType<Func>; // User
```

##### è·å–å‡½æ•°çš„å‚æ•°

```typescript
type ReturnType<T> = T extends (...args: infer P) => any ? P : any;

type Func = () => User;
type Test = ReturnType<Func>; // User
```

ä»¥classä½œä¸ºä¾‹å­,åŠ ä¸Š`new` ä¿®é¥°ç¬¦å³å¯ã€‚

```typescript
// è·å–å‚æ•°ç±»å‹
type ConstructorParameters<T extends new (...args: any[]) => any> = T extends new (...args: infer P) => any
  ? P
  : never;

// è·å–å®ä¾‹ç±»å‹
type InstanceType<T extends new (...args: any[]) => any> = T extends new (...args: any[]) => infer R ? R : any;

class TestClass {
  constructor(public name: string, public age: number) {}
}

type Params = ConstructorParameters<typeof TestClass>; // [string, number]

type Instance = InstanceType<typeof TestClass>; // TestClass
```



#### è”åˆç±»å‹è½¬äº¤å‰ç±»å‹

```typescript
type Intersect<T> = (T extends any ? ((x: T) => 0) : never) extends ((x: infer R) => 0) ? R : never

type EX1 = Intersect<{a:1} | {b:1}> // {a:1} & {b:1}

type EX2 = Intersect<[1,2] | string> // [1,2] & string
```

è¿™é‡Œä¸»è¦æ˜¯åˆ†ä¸ºä¸¤æ­¥

- é‡åˆ°å…¥å‚ä¸ºè”åˆç±»å‹æ—¶ï¼Œtsæ¡ä»¶ä¼šè¿›è¡Œæ‹†åˆ†`(T extends any ? ((x: T) => 0) : never)` ä¼šæ‹†åˆ†æˆ`(T1 extends any ? ((x: T) => 0) : never) | (T2 extends any ? ((x: T) => 0) : never) `
- ç¬¬äºŒé˜¶æ®µåŒæ ·æ˜¯è”åˆç±»å‹ï¼Œä½†æ˜¯ç”±äºå‡½æ•°å‚æ•°ä¼šè¿›è¡Œé€†å˜ï¼Œè¯¦æƒ…è§ `subtyping` ç« èŠ‚ï¼ˆå¾…æ›´æ–°ï¼‰ï¼Œæ‰€ä»¥æœ€åå¾—åˆ°çš„æ˜¯äº¤å‰ç±»å‹ã€‚`((x: T1) => 0) | ((x: T2) => 0) extends ((x: infer R) => 0) ? R : never  `



#### æ¨¡æ‹Ÿæ•°ç»„æ“ä½œ

##### Shift

```typescript
type ShiftAction<T extends any[]> = T extends [any, ...infer R ] ? R : never

type tuple = ['vue', 'react', 'angular'];

type resultWithShift = ShiftAction<tuple> // ["react", "angular"]
```

##### unshift

```typescript
type UnShiftAction<T extends any[], A > = T extends [...infer R ] ? [A,...R] : never

type tuple = ['vue', 'react', 'angular'];

type resultWithUnShift = UnShiftAction<tuple,'jquery'> // ["jquery", "vue", "react", "angular"]
```

##### push

```typescript
type AnyObject = { [K in keyof any]: any; };

type UnShiftAction<T extends any[], A  > = T extends [...infer R ] ? [A,...R] : never

type ReplaceValByOwnKey<T, S extends AnyObject> = { [P in keyof T]: S[P] };

type PushAction<T extends any[], E > = ReplaceValByOwnKey<UnShiftAction<T, any>, T & { [k: string]: E }>;

type tuple = ['vue', 'react', 'angular'];

type resultWithPush = PushAction<tuple,'jquery'> // ["vue", "react", "angular", "jquery"]
```

- é¦–å…ˆè¦æŠŠå…ƒç¥–çš„é•¿åº¦å¢åŠ ä¸€ä¸ªå•ä½ï¼Œæ‰€ä»¥è¿™é‡Œå°±ç›´æ¥è°ƒç”¨äº†shiftæ–¹æ³•ï¼Œç„¶åæŠŠå…ƒç¥–å’Œç´¢å¼•ç­¾åè¿›è¡Œé…åˆï¼Œæœ¬èº«å…ƒç¥–ä¹Ÿæ˜¯å¯¹è±¡ï¼Œæ‰€ä»¥å°±å’Œå¹³æ—¶å†™`interface`å®šä¹‰çš„æ—¶ä¸€è‡´ï¼Œèªæ˜çš„è¯»è€…ä¹Ÿè‚¯å®šå‘ç°äº†åªè¦æ–°å…ƒç¥–çš„é•¿åº¦å¤§äºåŸå…ƒç¥–ï¼Œæ— è®ºå¤§å¤šå°‘ä¸ªï¼Œåé¢å¡«å……çš„å†…å®¹ä¹Ÿå¿…å®šæ˜¯`E`
- ä»æ–°å…ƒç¥–`T`ä¸­å–å‡ºkeyï¼ŒæŠŠS[P]çš„æ•°æ®ä¸€ä¸ªä¸ªå¡«å…¥ï¼ŒåŸå…ƒç¥–æ•°æ®å¡«å®Œåï¼Œå°±ä¼šå¯åŠ¨ç´¢å¼•ç­¾åï¼Œæ·»åŠ å†…å®¹`E`

##### pop

```typescript
type AnyObject = { [K in keyof any]: any; };

type ShiftAction<T extends any[]> = T extends [any, ...infer R ] ? R : never

type ReplaceValByOwnKey<T, S extends AnyObject> = { [P in keyof T]: S[P] };

type PopAction<T extends any[]> = ReplaceValByOwnKey<ShiftAction<T>, T>;

type tuple = ['vue', 'react', 'angular'];

type resultWithPop = PopAction<tuple> // ["vue", "react"]
```

##### concat

```typescript
type ShiftAction<T extends any[]> = T extends [any, ...infer R ] ? R : never
type ConcatAction<T1 extends any[], T2 extends any[], T extends any[] = T2 > = {
  0: ConcatAction<ShiftAction<T1>, [], [ T1[0], ...T ]>,
  1: T
}[T1 extends [] ? 1 : 0]

type tuple1 = ['vue', 'react', 'angular'];

type tuple2 = ['lodash', 'dayjs', 'eslint'];

type resultWithConcat = ConcatAction<tuple1,tuple2> // ["angular", "react", "vue", "lodash", "dayjs", "eslint"]
```

è¿™é‡Œä½¿ç”¨äº†`Type`é€’å½’æ–¹æ³•ï¼Œä¸»è¦æ€è·¯æ˜¯éœ€è¦ä¸€ä¸ªå·¥å…·äººå®¹å™¨`T`ï¼Œ`T`çš„åˆå§‹å€¼å°±æ˜¯`T2`ï¼Œé‚£ä¹ˆåªè¦æŠŠå…ƒç¥–1çš„å†…å®¹åœ¨é€’å½’ä¸­æ¯æ¬¡æ”¾å…¥ä¸€ä¸ªåˆ°Tä¸­ï¼Œå¹¶åˆ é™¤å³å¯ã€‚

#### è”åˆç±»å‹è½¬å…ƒç¥–
```typescript
// union to intersection of functions
type UnionToIoF<U> =
    (U extends any ? (k: (x: U) => void) => void : never) extends
    ((k: infer I) => void) ? I : never

// return last element from Union
type UnionPop<U> = UnionToIoF<U> extends { (a: infer A): void; } ? A : never;
type tests2=UnionPop<'a' | 'b' | 'c'>
// prepend an element to a tuple.
type Prepend<U, T extends any[]> =
    ((a: U, ...r: T) => void) extends (...r: infer R) => void ? R : never;

type UnionToTuples<Union, Result extends any[]=[]> = {
    1: Result;
    0: UnionToTuples_<Union, UnionPop<Union>, Result>;
    // 0: UnionToTuples<Exclude<Union, UnionPop<Union>>, Prepend<UnionPop<Union>, Result>>
}[[Union] extends [never] ? 1 : 0];

type UnionToTuples_<Union, Element, Result extends any[]> =
    UnionToTuples<Exclude<Union, Element>, Prepend<Element, Result>>;

type finalResult = UnionToTuples<'a' | 'b' | 'c'>
```
è¿™æ˜¯æœ¬ä¾‹ä¸­éš¾åº¦æœ€é«˜çš„ä¾‹å­ä¹‹ä¸€ï¼ŒåŒæ—¶ä¹Ÿæ˜¯æœ€ç»¼åˆçš„è¿ç”¨ã€‚
### ç« èŠ‚å°ç»“ï¼šå›¾çµå®Œå¤‡

åœ¨æœ¬ç« èŠ‚ä¸­ï¼Œæˆ‘ä»¬å¯¹ `TypeScript` ç±»å‹å£°æ˜ç©ºé—´ï¼ˆ`Type`ï¼‰æ¨¡æ‹Ÿäº†æ•°ç»„ï¼Œé€’å½’ï¼Œåˆ¤æ–­ç­‰æ–¹æ³•ï¼Œå¦‚æœè¯»è€…å¯ä»¥ç†Ÿç»ƒè¿ç”¨ä»¥ä¸ŠæŠ€å·§ï¼Œé‚£ä¹ˆé‡åˆ°å¾ˆå¤šåœºæ™¯éƒ½å¯ä»¥å’Œæ°´æœå¿è€…ä¸€æ ·ç®€å•å•¦ã€‚ä½†è¿™ä¹Ÿè®©ä¸€äº›è¯»è€…äº§ç”Ÿäº†æ€è€ƒï¼Œ`Type`åŸºæœ¬å¯ä»¥æ¨¡æ‹Ÿè¯­è¨€çš„æ•°æ®ç»“æ„ä¸æ–¹æ³•ï¼Œé‚£ä¹ˆå®ƒç©¶ç«Ÿèƒ½ä¸èƒ½ç®—ä¸€é—¨è¯­è¨€å‘¢ï¼Ÿç¬”è€…æ€è€ƒåè§‰å¾—Typeè™½ç„¶çœ‹ä¸Šå»æ˜¯ä¸€å¥—æ¯”è¾ƒå®Œå¤‡çš„ç¼–ç¨‹è¯­è¨€ï¼Œä½†æ˜¯å…¶æ ¹æœ¬æ— æ³•æ»¡è¶³å›¾çµå®Œå¤‡çš„äº”ä¸ªæ ‡å‡†ï¼Œå†µä¸”å›¾çµå®Œå¤‡ä½œä¸ºä¸€ç§æ•°å­¦æ¨¡å‹å…¶å«ä¹‰æ˜¯ï¼šèƒ½å¤Ÿè§£å†³æ‰€æœ‰å¯è®¡ç®—çš„è®¡ç®—é—®é¢˜ï¼›æ‰€ä»¥`Type`æ— æ³•æˆä¸ºä¸€é—¨ `GPL` ï¼Œä½† `TypeScript` æ‹¥æœ‰å¯è¿›è¡Œè‡ªä¸¾çš„parserï¼Œå†…éƒ¨è¡Œä¸ºæ˜¯å°†è‡ªèº«è½¬æ¢ä¸º `JavaScript` ã€‚ç»¼ä¸Šæ‰€è¿°`TypeScript`ä½œä¸º`Javascript`çš„è¶…é›†ï¼Œå…¶æœ¬èº«æ›´åŠ ç¬¦åˆå¤–éƒ¨`DSL`çš„è®¾å®šã€‚

