## 工作实践
> 笔者在此章节默认读者已有一定的网络基础，并对shell, nginx, lua / perl 有一定了解

在熟悉HTTP的基本体系后，我们进入工作实践板块，在此板块中，笔者会列举出在实际工作中遇到的前端工程师需要处理的网络与缓存相关的问题，以及会给出相应的解决方案。

### 前端资源自动进行静默更新

#### 问题产生现象

前后端最新资源在部署完成后进行测试，在测试过程中发现前端调用了后端历史版本的接口，然而此接口已经在现版本被废弃，遂后端返回响应码 **404**，以及更多稀碎而且非常耗费人精力的杂事。

#### 分析问题原因
我司前端项目在部署到服务器后，shell脚本中未执行 `nginx -s reload`，并且本地资源默认是强缓存的，这就直接导致如果用户未手动清除资源本地缓存资源，那么前端的版本依旧是部署前的历史版本，而后端服务由Tomcat进行管理，所以前端资源无论是否是历史版本，拿到的后端响应报文理论上始终对应最新的服务，那么解决的方法也很简单，只需要给shell脚本补足`nginx -s reload`即可。

#### 新问题与新需求
虽然添加`nginx -s reload`可以解决本地资源滞后的问题，但是需要用户进行手动的刷新浏览器，亦或是打开一个新窗口重新打开项目`URI`。除此之外还有特殊情况：
> 在资源部署更新过程中，用户始终在平台上处于在线状态，之后假设用户去上厕所了，没有请求任何的接口。此时资源部署完毕了，用户上厕所回来后紧接着进行HTTP请求，依然会出现前后端资源版本不一致的问题。

#### 符合需求的思路
了解完需求后，笔者仔细思考了整条链路中可能出现的其他情况，除了缓存的资源以外还有本地的数据，例：`localstorage`、`sessionstorage`、`indexDB`等也应在考虑范围内，他们存储数据的结构随着前端版本的升级很有可能不一致，需要一并考虑进处理范畴。

最直接的处理思路是后端直接在每一个接口返回相应的版本号，前端在本地存储中若没有存在版本号，则进行保存；如果存在版本号则和后端响应中的版本号进行比对，值若不一致，就清除本地的全部数据。

上述方案粗看没什么毛病，但是如果细想，有概率会出现以下情况：
- 如果 `Tomact` 服务器出现故障，那么请求会返回 **404** 错误
- 旧版本前端资源的**请求`URI`与新版本的 `URI`不一致**，那么会返回**404** ，因此把工作交给后端服务有一定风险。
- 其他情况导致的后端接口响应异常，拿不到制定的版本标示

综上考虑，在 `nginx` 层进行处理是整条链路的最佳位置，在此处理同时能避免被链路后的环境干扰。由于nginx本身的定位是代理服务器，因此不论我们是否了解nginx本身，都可以推测出`nginx`有独立返回响应信息的能力。我们可以命令 `nginx` 在满足某些条件的时候跳过 `Tomcat` 反向代理，直接返回制定的响应码亦或是响应报文；同时由于整条链路还是比较长，因此在正式实施前，制定执行的 `RoadMap` 是非常不错的习惯

#### RoadMap

首先，由于我们的业务是 ToB 类型的，因此在方案中我在强缓存基础上开启协商缓存，这样做理论上来说会更好，但是也相应的增加了服务器的负担，可以根据业务场景决定是否开启协商缓存。从整个方案的角度看，协商缓存的开关影响也不大。方案的具体RoadMap如下：

- [ ] 利用部署系统的 `shell` 脚本在`centOS`端环境变量中加入hash标识符（`ETAG`）
- [ ] nginx配置文件读取系统环境变量获取标识符，并添加以下逻辑：如果请求头**if-match**和环境变量中的`Etag`值一致或者请求头中没有**if-match**，不进行任何操作，当**if-match**和环境变量中的`Etag`值不一致，就返回**412 Precondition Failed**（先决条件失败）状态码
- [ ]  用户端如果没有标识符，获取响应返回`ETag`标识符并且携带**cache-control:no-cache**(开启协商缓存)，客户端把`ETag`存储在`localstorage`中，之后的请求都把标识符放到请求头**if-match** 中
- [ ] `nginx` 对比状态码，若一致，反向代理进入 `Tomcat` 处理请求
- [ ]  重新部署并运行 `shell` 脚本，读取当前系统环境变量，生成一个**新的hash值**，并且最后`nginx -s reload`，确保客户端服务是最新版本。
- [ ]  客户端发送请求，nginx拦截到发现etag值不一致，返回 412 状态码,并返回正确的标识符
- [ ]  前端匹配到 412 状态码，执行reload，清除indexDB、localstorage等操作，最后保存正确的标识符。

##### step1
这里首先需要做的就是在centOS的容器中记录下前端资源的变更标示。

由此为出发点可以选择的方案有三种：

1. 直接在shell脚本中修改 nginx 配置文件给予最新的资源标识符，但是耦合性太强了，不推荐使用；
2. 如果要进行解耦那就需要存放变量的容器，考虑到nginx配置文件需要能够读取容器，那么放进系统的环境变量就是最优解，利用UUID即可在每次运行`shell`脚本时每次生成
3. 在现在企业中比较流行的部署方案中会使用 `k8s`，这是一种多集群管理模式。在此环境下，那么UUID就显得不太可靠了，因此选择在前端资源打包完毕的`dist`文件中加入项目的`key-value`（对应项目名与版本）再有shell脚本进行读取是一个不错的选择。
```shell
# 这里以使用 UUID 为例
sed -i '/export ETAG_PATH=/d' ~/.bash_profile
UUID=$(cat /proc/sys/kernel/random/uuid)
sed -i '$a export ETAG_PATH='${UUID}'' ~/.bash_profile
source ~/.bash_profile
echo env
```
运行完毕后，系统输出如图：

【图】


##### step2
接下来就需要更改 `nginx` 配置文件了，在配置文件中能够读取系统环境变量的方法目前我所知的有两种:

- 使用 `lua` 脚本读取

首先得用`env`定义作为key，才可以在后续进行使用

```
user nginx;
worker_processes auto;

...

env ETAG_PATH;

http {
    ...
    server {
        
        location / {
            set_by_lua $ETAG_PATH 'return os.getenv("ETAG_PATH")';
        }
        
    }
    
}
```

- 使用 `perl` 脚本读取

```
user nginx;
worker_processes auto;

...

env ETAG_PATH;

http {
    ...
    server {
        
        location / {
            perl_set $ETAG_PATH 'sub { return $ENV{"ETAG_PATH"}; }';
        }
        
    }
    
}
```
这里默认 `nginx` 已经安装了 `lua-nginx-module` 或是 `http_perl_module`。

##### step3

读取完毕系统环境变量后，`nginx` 需要根据 RoadMap 所述，取出请求中的请求头`if_match`进行判别并返回相应的响应码与响应头，最后开启协商缓存。

```
location / {
	 if ($http_if_match = "") {
		set $flag "${flag}0";
	 }
	 if ($http_if_match != "") {
                set $flag "${flag}1";
     }
	 if ($http_if_match = $ETAG_PATH) {
		set $flag "${flag}0";
     }
	 if ($http_if_match != $ETAG_PATH) {
		set $flag "${flag}1";
	 }
	 if ($flag = '011') {
		add_header ETag $ETAG_PATH;
        add_header cache-control no-cache;
		return 412 ;
	 }
	 if ($flag = '010') {
		add_header ETag $ETAG_PATH;
        add_header cache-control no-cache;
	 }
	 if ($flag = '001') {
	 	add_header ETag $ETAG_PATH;
        add_header cache-control no-cache;
	 }
    }
```

##### step4

完成上述步骤后，回到熟悉的前端。能走到这一步问题已经非常容易解决，只需要把响应报文主体的 `ETag` 字段拿出来做逻辑判断即可，若响应报文的`Etag`与本地保存的 `Etag` 不一致就弹框提示用户系统进行更新，并自动刷新浏览器；随后清除本地 `Etag` 与 `indexDB` , `localstorage` 等其他本地资源即可解决。

#### websocket 推送

根据上述步骤操作后我们可以发现在资源更新以后，用户必须手动发起一次请求，才会触发后续的一系列连锁反应，这里还是显得不够智能。所以我们可以使用 `websocket` 来代替上述方案，笔者虽然没有进行实践，但是可以提供如下思路，这也可以算作为一个BFF的应用思路：

1. 在每次部署时产生 `ETag` 到系统环境变量不变
2. nginx 配置只需要增加请求头 `upgrade` 等升级为`websocket`协议，不需要获取系统环境变量
3. 反向代理需要修改到新的服务，可以是node服务，由于这一层服务并不是实际处理请求的位置，因此作为静默更新响应的服务商是合适的。
4. 以node服务为例，获取系统环境变量，进行判定，如果判定ETag不一致，主动推送给客户端进行资源更新。反之由node服务最终转发给`Tomcat`服务器完成请求的处理。


#### 总结

综上所述，我们成功解决了前端资源静默刷新的需求，但是由于笔者水平有限，此方案肯定有值得优化的地方，因此笔者在文末对方案中仍然存在的问题做一下抛砖引玉，若读者有更好的建议，也对本文进行评论，帮助笔者完善此方案。

待完善的几个方面：

1. shell脚本修改系统环境变量时，需要确定不会覆盖系统原有环境变量，这在一定程度上增加了运维成本
2. nginx需要安装`lua`或者`perl`模块才可以读取系统环境变量，增加了运维的成本
3. `websocket`方案也许有没有考虑到的技术细节，亦或是改进点